"""Agentic repository for two-tier annotation pipeline."""

import sqlite3
import json
import logging
from typing import Optional, Dict, Any, List
from datetime import datetime

logger = logging.getLogger(__name__)


class AgenticAnnotationRepo:
    """
    Repository for agentic annotation pipeline with two-tier architecture.

    Flow:
    1. annotation_request: Stores raw MedGemma + Gemini validated + Pydantic outputs
    2. annotation: Receives clean summaries generated by Gemini
    """

    def __init__(self, db_path: str = './DB/annotations.db'):
        """Initialize database connection."""
        self.connection = sqlite3.connect(db_path, check_same_thread=False)
        self.cursor = self.connection.cursor()
        self.cursor.execute("PRAGMA foreign_keys = ON")
        logger.info(f"AgenticAnnotationRepo initialized: {db_path}")

    def save_annotation_request(
        self,
        set_name: int,
        path_url: str,
        patient_id: Optional[int],
        medgemma_raw: str,
        gemini_validated: Dict[str, Any],
        validation_attempt: int,
        validation_status: str,
        pydantic_output: Dict[str, Any],
        confidence_score: float,
        gemini_enhanced: bool = False,
        gemini_report: Optional[str] = None,
        urgency_level: Optional[str] = None,
        clinical_significance: Optional[str] = None,
    ) -> int:
        """
        Save raw pipeline output to annotation_request staging table.

        Args:
            set_name: Dataset identifier
            path_url: Image file path
            patient_id: Patient ID (can be None)
            medgemma_raw: Raw MedGemma text output
            gemini_validated: Gemini-validated structured dict
            validation_attempt: Number of validation attempts
            validation_status: 'success', 'retry', 'fallback'
            pydantic_output: Full AnnotationOutput dict
            confidence_score: Confidence score (0.0-1.0)
            gemini_enhanced: Whether Gemini enhancement was applied
            gemini_report: Optional professional report
            urgency_level: Optional urgency assessment
            clinical_significance: Optional clinical significance

        Returns:
            int: request_id (auto-generated)
        """

        # Serialize dicts to JSON strings
        gemini_validated_json = json.dumps(gemini_validated, ensure_ascii=False)
        pydantic_output_json = json.dumps(pydantic_output, ensure_ascii=False)

        try:
            self.cursor.execute(
                """
                INSERT OR REPLACE INTO annotation_request (
                    set_name, path_url, patient_id,
                    medgemma_raw, gemini_validated, validation_attempt, validation_status,
                    pydantic_output, confidence_score,
                    gemini_enhanced, gemini_report, urgency_level, clinical_significance,
                    processed
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 0)
                """,
                (
                    set_name, path_url, patient_id,
                    medgemma_raw, gemini_validated_json, validation_attempt, validation_status,
                    pydantic_output_json, confidence_score,
                    gemini_enhanced, gemini_report, urgency_level, clinical_significance
                )
            )
            self.connection.commit()

            request_id = self.cursor.lastrowid
            logger.info(f"Saved annotation_request {request_id}: {path_url} (status={validation_status})")
            return request_id

        except sqlite3.IntegrityError as e:
            logger.error(f"Failed to save annotation_request: {e}")
            raise

    def get_annotation_request(self, request_id: int) -> Optional[Dict[str, Any]]:
        """
        Retrieve annotation request by ID.

        Returns:
            Dict with all fields, or None if not found
        """
        result = self.cursor.execute(
            "SELECT * FROM annotation_request WHERE id = ?",
            [request_id]
        ).fetchone()

        if not result:
            return None

        # Parse row into dict
        columns = [desc[0] for desc in self.cursor.description]
        row_dict = dict(zip(columns, result))

        # Deserialize JSON fields
        if row_dict.get('gemini_validated'):
            row_dict['gemini_validated'] = json.loads(row_dict['gemini_validated'])
        if row_dict.get('pydantic_output'):
            row_dict['pydantic_output'] = json.loads(row_dict['pydantic_output'])

        return row_dict

    def get_unprocessed_requests(self, set_name: Optional[int] = None) -> List[Dict[str, Any]]:
        """
        Get all annotation requests that haven't been processed yet.

        Args:
            set_name: Optional filter by dataset

        Returns:
            List of request dicts
        """
        if set_name is not None:
            results = self.cursor.execute(
                "SELECT * FROM annotation_request WHERE processed = 0 AND set_name = ? ORDER BY created_at",
                [set_name]
            ).fetchall()
        else:
            results = self.cursor.execute(
                "SELECT * FROM annotation_request WHERE processed = 0 ORDER BY created_at"
            ).fetchall()

        columns = [desc[0] for desc in self.cursor.description]
        requests = []

        for row in results:
            row_dict = dict(zip(columns, row))

            # Deserialize JSON
            if row_dict.get('gemini_validated'):
                row_dict['gemini_validated'] = json.loads(row_dict['gemini_validated'])
            if row_dict.get('pydantic_output'):
                row_dict['pydantic_output'] = json.loads(row_dict['pydantic_output'])

            requests.append(row_dict)

        return requests

    def process_request_to_annotation(
        self,
        request_id: int,
        gemini_summary: str,
        primary_label: str
    ) -> None:
        """
        Process an annotation_request into the annotation table.

        This creates a clean annotation entry with Gemini-generated summary.

        Args:
            request_id: The annotation_request ID to process
            gemini_summary: Gemini-generated summary for desc field
            primary_label: Primary label for the annotation
        """

        # Get the request
        request = self.get_annotation_request(request_id)
        if not request:
            raise ValueError(f"Request {request_id} not found")

        # Ensure label and patient exist
        self.add_label(primary_label)
        if request['patient_id']:
            self.add_patient(request['patient_id'], "Auto")

        try:
            # Insert into annotation table
            self.cursor.execute(
                """
                INSERT OR REPLACE INTO annotation (
                    set_name, path_url, label, patient_id, desc, request_id
                ) VALUES (?, ?, ?, ?, ?, ?)
                """,
                (
                    request['set_name'],
                    request['path_url'],
                    primary_label,
                    request['patient_id'] or 0,
                    gemini_summary,
                    request_id
                )
            )

            # Mark request as processed
            self.cursor.execute(
                "UPDATE annotation_request SET processed = 1 WHERE id = ?",
                [request_id]
            )

            self.connection.commit()
            logger.info(f"Processed request {request_id} â†’ annotation: {primary_label}")

        except Exception as e:
            logger.error(f"Failed to process request {request_id}: {e}")

            # Log error in request
            self.cursor.execute(
                "UPDATE annotation_request SET processing_error = ? WHERE id = ?",
                [str(e), request_id]
            )
            self.connection.commit()
            raise

    def get_annotations(self, set_name: int, paths: Optional[List[str]] = None) -> List[tuple]:
        """
        Retrieve annotations for a specific set (compatible with old API).

        Args:
            set_name: Dataset identifier
            paths: Optional list of paths to filter

        Returns:
            List of annotation tuples
        """
        if paths is None:
            results = self.cursor.execute(
                'SELECT * FROM annotation WHERE set_name=?',
                [set_name]
            )
        else:
            placeholders = ','.join(['?'] * len(paths))
            query = f'SELECT * FROM annotation WHERE set_name=? AND path_url IN ({placeholders})'
            results = self.cursor.execute(query, [set_name] + paths)

        return results.fetchall()

    def get_annotation_with_request(self, set_name: int, path_url: str) -> Optional[Dict[str, Any]]:
        """
        Get annotation with its full request data (for debugging/tracing).

        Returns:
            Dict with both annotation and request data
        """
        result = self.cursor.execute(
            """
            SELECT
                a.*,
                r.medgemma_raw,
                r.gemini_validated,
                r.validation_status,
                r.confidence_score,
                r.gemini_enhanced,
                r.gemini_report
            FROM annotation a
            LEFT JOIN annotation_request r ON a.request_id = r.id
            WHERE a.set_name = ? AND a.path_url = ?
            """,
            [set_name, path_url]
        ).fetchone()

        if not result:
            return None

        columns = [desc[0] for desc in self.cursor.description]
        return dict(zip(columns, result))

    def add_label(self, label_name: str):
        """Register a label (idempotent)."""
        try:
            self.cursor.execute('INSERT INTO label VALUES (?)', [label_name])
            self.connection.commit()
        except sqlite3.IntegrityError:
            pass  # Label already exists

    def add_patient(self, patient_id: int, patient_name: str):
        """Register a patient (idempotent)."""
        try:
            self.cursor.execute('INSERT INTO patient VALUES (?, ?)', [patient_id, patient_name])
            self.connection.commit()
        except sqlite3.IntegrityError:
            pass  # Patient already exists

    def get_pipeline_stats(self, set_name: Optional[int] = None) -> Dict[str, Any]:
        """
        Get statistics about the annotation pipeline.

        Returns:
            Dict with counts and metrics
        """

        if set_name:
            where_clause = "WHERE set_name = ?"
            params = [set_name]
        else:
            where_clause = ""
            params = []

        stats = {}

        # Total requests
        result = self.cursor.execute(
            f"SELECT COUNT(*) FROM annotation_request {where_clause}",
            params
        ).fetchone()
        stats['total_requests'] = result[0]

        # Processed vs unprocessed
        result = self.cursor.execute(
            f"SELECT COUNT(*) FROM annotation_request {where_clause} {'AND' if where_clause else 'WHERE'} processed = 1",
            params
        ).fetchone()
        stats['processed'] = result[0]
        stats['unprocessed'] = stats['total_requests'] - stats['processed']

        # Validation status breakdown
        result = self.cursor.execute(
            f"SELECT validation_status, COUNT(*) FROM annotation_request {where_clause} GROUP BY validation_status",
            params
        ).fetchall()
        stats['validation_status'] = {row[0]: row[1] for row in result}

        # Enhanced vs not enhanced
        result = self.cursor.execute(
            f"SELECT COUNT(*) FROM annotation_request {where_clause} {'AND' if where_clause else 'WHERE'} gemini_enhanced = 1",
            params
        ).fetchone()
        stats['gemini_enhanced_count'] = result[0]

        # Average confidence
        result = self.cursor.execute(
            f"SELECT AVG(confidence_score) FROM annotation_request {where_clause}",
            params
        ).fetchone()
        stats['avg_confidence'] = round(result[0], 3) if result[0] else 0.0

        return stats
